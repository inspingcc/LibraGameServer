package com.insping.libra.sock;import java.io.IOException;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;import com.insping.Instances;import com.insping.libra.sock.net.codec.LibraDecoder;import com.insping.libra.sock.net.codec.LibraEncoder;import com.insping.libra.sock.net.handler.internal.HeartbeatHandler;import com.insping.libra.sock.net.handler.internal.ServerRegisterHandler;import com.insping.libra.sock.net.handler.SockLogicHandler;import com.insping.libra.world.LibraConfig;import com.insping.log.LibraLog;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.LengthFieldBasedFrameDecoder;public class SockServer implements Instances {    private SockServer() {    }    private static SockServer instance = new SockServer();    public static SockServer getInstance() {        return instance;    }    boolean isRunning = false;    EventLoopGroup group = new NioEventLoopGroup();    private ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);    public void start() {        // 配置NIO线程组        try {            Bootstrap b = new Bootstrap();            b.group(group).channel(NioSocketChannel.class).option(ChannelOption.TCP_NODELAY, true)                    .handler(new ChannelInitializer<SocketChannel>() {                        @Override                        public void initChannel(SocketChannel ch) throws IOException {                            ch.pipeline().addLast("frameDecoder", new LengthFieldBasedFrameDecoder(3 * 1024, 0, 2));                            ch.pipeline().addLast("protobufDecoder", new LibraDecoder());                            // ch.pipeline().addLast("frameEncoder", new                            // ProtobufVarint32LengthFieldPrepender());                            ch.pipeline().addLast("protobufEncoder", new LibraEncoder());                            ch.pipeline().addLast(new ServerRegisterHandler());                            ch.pipeline().addLast(new HeartbeatHandler());                            ch.pipeline().addLast(new SockLogicHandler());                        }                    });            // 发起异步连接操作            ChannelFuture f = b.connect(LibraConfig.GATEWAY_IP, LibraConfig.GATEWAY_PORT).sync();            LibraLog.info("SockServer-start : 逻辑服务器启动成功! port : " + LibraConfig.GATEWAY_PORT);            isRunning = true;            // 等待客户端链路关闭            f.channel().closeFuture().sync();        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            isRunning = false;            LibraLog.info("SockServer-start : SockServer exception shutdown server! reconnection...");            // 所有资源释放完成之后，清空资源，再次发起重连操作            executor.execute(() -> {                        try {                            TimeUnit.SECONDS.sleep(5);                            start();// 发起重连操作                        } catch (Exception e) {                            e.printStackTrace();                        }                    }            );        }    }    public void shutdown() {        group.shutdownGracefully();        isRunning = false;        LibraLog.info("SockServer-shutdown : shutdown success!");    }}